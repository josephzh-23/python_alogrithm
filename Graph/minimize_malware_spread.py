'''

This is the coding file here

graph[i][j] == 1 connected

So to simplify this

If initial [0, 2, 3],
0 - 1
2 - 3
4 - 5

Here we would remove 0, since 0 removed, no more spread
becomes [2, 3 ]      M = 3 # of infected

If remove 2, becomes [0, 3]     M = 4
3 would spread to 2, 1 to 0


So find cc with only 1 initial infectino here
IF we remove 2, not helping

Step 1 : initialization
parent would be [0, 1, 2, 3]
size would be [1, 1, 1, 1]

Size: represents jthe tree for which node i is the root here. Initially each node is a
separate group of 1 here

Union Operations: Next, we examine the adjacency matrix and perform union operations.

For graph[0][1], nodes 0 and 1 are connected, so we unite them, which leads to:
parent being updated to [0, 0, 2, 3]
size being updated to [2, 1, 1, 1]

And on the next go here:
For graph[1][2], nodes 1 and 2 are connected,
 and indirectly node 0 is also connected to node 2,
 so we unite them under root 0:

parent being updated to [0, 0, 0, 3]
size being updated to [3, 1, 1, 1]


graph[3] has no connections thus no union operations are needed.


'''

from typing import List


def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
    # Number of nodes in the graph.
    num_nodes = len(graph)

    # Parent array for Disjoint Set Union (DSU).
    parent = list(range(num_nodes))

    # Size array to keep track of the size of each component.
    component_size = [1] * num_nodes

    # Function to find the representative (leader) of the component.
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    # Union operation to merge two components into one.
    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            if graph[i][j] == 1:
                parent_i, parent_j = find(i), find(j)
                if parent_i != parent_j:
                    parent[parent_i] = parent_j
                    component_size[parent_j] += component_size[parent_i]

    # Initialize to positive infinity for comparison purposes.
    min_infected = float('inf')

    # Result node which gets minimum malware spread.
    result_node = initial[0]

    # Sort the list to ensure that the smallest index is returned in case of ties.
    initial.sort()

    for i in range(len(initial)):
        total_infected = 0
        infected_set = set()
        for j in range(len(initial)):
            if i == j:
                continue
            # Find the parent node of the j-th initially infected node.
            parent_node = find(initial[j])
            if parent_node in infected_set:
                continue
            # Add this parent node to the infected set and increment the total infected counter.
            infected_set.add(parent_node)
            total_infected += component_size[parent_node]

        # We want the smallest infected here
        if min_infected > total_infected:
            min_infected = total_infected
            result_node = initial[i]

    # Return the node that if removed, minimizes the spread of malware.
    return result_node