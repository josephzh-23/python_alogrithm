

'''
The situation here is quite simple here 

1. Could delete immediately here 

2. Node not null and has a right child, 

could be replaced by successor (the smallest node after the current one)
Go to the irght as manhy times as you can 


3. Node is not a leaf, has no right child,

but it has a left child. That means that its successor is
 somewhere upper in the tree but we don't want to go back. Let's use the predecessor here which is somewhere lower in the left subtree. 
The node could be replaced by its predecessor and then one could proceed down recursively to delete the predecessor.


4. 
'''

class Solution:
    # One step right and then always left
    def successor(self, root: TreeNode) -> int:
            root = root.right
            while root.left:
                root = root.left
            return root.val
        
    # One step left and then always right
    def predecessor(self, root: TreeNode) -> int:
        root = root.left
        while root.right:
            root = root.right
        return root.val

    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None

        # delete from the right subtree
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        # delete from the left subtree
        elif key < root.val:
            root.left = self.deleteNode(root.left, key)
        # delete the current node
        else:
            # the node is a leaf
            if not (root.left or root.right):
                root = None
            # The node is not a leaf and has a right child
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            # the node is not a leaf, has no right child, and has a left child    
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)
                        
        return root